<!DOCTYPE html>
<html>
<meta charset="utf-8">

<head>
    <!-- <script src="mqttws31.js" type="text/javascript"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.5.13/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.20.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.20.1/locale/fi.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <!-- <script src="charts.js"></script> -->

    <link rel="stylesheet" href="jquery.bFlipText.css">
    <script type="text/javascript" src="jquery.bFlipText.js"></script>

    <link href="https://fonts.googleapis.com/css?family=Mina" rel="stylesheet">
    <style id="pageStyles">
        ul.matches {
            list-style-type: none;
        }

        li.player {
            cursor: copy;
        }
    </style>
    <style id="chartStyles">
        .areaChart,
        .linechart {
            height: 200px;
            width: 50%;
            border: 1px solid #ddd;
        }

        .axis--x path {
            display: none;
        }

        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .area {
            fill: #76BF8A
        }

        #mqttlog {
            height: 200px;
            overflow: auto;
            background-color: beige;
            border: 1px solid burlywood;
        }

        #mqttlog p {
            margin: 0.1em;
            font-family: monospace;
            font-size: smaller;
            color: darkslateblue;
        }

        .currentMatch {
            border: 1px solid salmon;
        }

        .currentMatch .players {
            display: flex;
        }

        .currentMatch .player {
            border: 1px solid salmon;
            flex-grow:1;
            /* display: inline-block;
            width: 49%; */
        }
        .currentMatch .player .personName .name{
            font-family: 'Mina', sans-serif;
            font-weight: bold;
            font-size: 10vh;
        }
        
    </style>
</head>

<body>
        <div id="my_flip1"></div>

        <div id="my_flip3" class="my_flip_multi"></div>
        <input type="text" value="write here" id="mytext">
        <input type="button" value="Change 1st Text" id="myflip_submit1"/>
        <script type="text/javascript">
            //initializing script by id with style
            var my_style = {'width': '90px', 'font-size': '90px', 'background': '#fff', 'color': '#000'};
            $('#my_flip1').bFlipText({text: '01', css: my_style});
            //initializing script by class with no style & with initial text
            $('#myflip_submit1').click(function () {
                $('#my_flip1').bFlipTextPlay($('#mytext').val());
            });
        </script>
    <div ID="app">
        <div class="currentMatch match">
            <div class="startTime">{{currentMatch.startTime | moment}}</div>
            <div class="players">
                <div class="player" v-for="player in currentMatch.players">
                    <div class="personName">
                        <div>Name:</div>
                        <div class="name" :style="{ color: player.person.color}">{{player.person.name}}</div>
                    </div>
                    <div class="remote">Remote: {{player.remote.name}}</div>
                    <div class="points" :id="'flipPoints' + player.person.ID">
                        {{player.points.length}}
                    </div>
                </div>
            </div>
            <linechart :id="'lineChart_' + currentMatch.ID" :match="currentMatch" :latestpoint="currentMatch.latestPoint" :currpoints="currentMatch.playerScores"
            :ceil="3"></linechart>

        </div>

        <button click="$('#my_flip').bFlipTextPlay({text: '55'});">add</button>
        <ul class="matches">
            <li v-for="match in matches">
                <ul class="match">
                    <li>Date: {{ match.startTime | moment }}</li>
                    <li>Players: {{ match.playerCount }}</li>
                    <li>Enough players : {{match.enoughPlayers ? "Yes" : "No"}}</li>
                    <li>Players
                        <ul>
                            <li v-for="player in match.players">
                                <div class="person">{{ player.person }}</div>
                                <div class="remote">{{ player.remote }}</div>
                                <div class="remote">{{ player.points }}</div>
                            </li>
                        </ul>
                    </li>
                    <li>Points {{ match.playerScores }} latest: {{ match.latestPoint }}</li>
                    <li>
                        <linechart :id="'lineChart_' + match.ID" :match="match" :latestpoint="match.latestPoint" :currpoints="match.playerScores"
                            :ceil="3"></linechart>
                        <!-- <areachart :id="'areaChart_' + match.ID" :data="match.playerScores" :ceil="3"></areachart> -->
                    </li>
                </ul>
            </li>
        </ul>
        <button v-on:click="addMatch">Add match</button>
        <br>
        <select class="persons" v-model="selectedPerson">
            <option v-for="person in persons" :value="person">
                Name: {{ person.name }}
            </option>
        </select>
        <select class="remotes" v-model="selectedRemote">
            <option v-for="remote in remotes" :value="remote">
                ID: {{ remote.buttonIDs[0] }}
            </option>
        </select>
        <button v-on:click="addSelectedPlayerWithRadio()">Add player</button>
        <br> {{ message }}
        <!-- <button class="btnPoint" data-player="antti" data-points="1">+1</button>
        <button class="btnPoint" data-player="antti" data-points="-1">-1</button> -->
        <div id="mqttlog">MQTT log</div>
    </div>
</body>
<script type="text/javascript">
    // Create a client instance
    client = new Paho.MQTT.Client("m23.cloudmqtt.com", 38577, "web_" + parseInt(Math.random() * 100, 10));
    //Example client = new Paho.MQTT.Client("m11.cloudmqtt.com", 32903, "web_" + parseInt(Math.random() * 100, 10));

    // set callback handlers
    client.onConnectionLost = onConnectionLost;
    client.onMessageArrived = onMessageArrived;
    var options = {
        useSSL: true,
        userName: "ezbvjyrv",
        password: "hS5ElErtR3eD",
        onSuccess: onConnect,
        onFailure: doFail
    }

    // connect the client
    client.connect(options);

    // called when the client connects
    function onConnect() {
        // Once a connection has been made, make a subscription and send a message.
        console.log("onConnect");
        client.subscribe("tabletennis/433toMQTT");
        message = new Paho.MQTT.Message("Hello CloudMQTT");
        message.destinationName = "tabletennis";
        client.send(message);
    }

    function doFail(e) {
        console.log(e);
    }

    // called when the client loses its connection
    function onConnectionLost(responseObject) {
        if (responseObject.errorCode !== 0) {
            console.log("onConnectionLost:" + responseObject.errorMessage);
        }
    }

    // called when a message arrives
    function onMessageArrived(message) {
        //console.log("onMessageArrived:" + message.destinationName + ":" + message.payloadString);
        $("#mqttlog").append("<p>" + message.destinationName + ":" + message.payloadString + "</p>");
        $("#mqttlog").animate({
            scrollTop: $('#mqttlog').prop("scrollHeight")
        }, 200);
        app.addPoint(message.payloadString);
    }

    function sendPoint(name, points) {
        message = new Paho.MQTT.Message(JSON.stringify({
            name: name,
            points: points
        }));
        message.destinationName = "tabletennis/";
        client.send(message);
    }
    // $(function () {
    //     $(".btnPoint").click(x =>
    //         sendPoint($(x.target).data("player"), $(x.target).data("points")));
    // })
</script>
<script name="helpers">
    function guidGenerator() {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
    }
</script>
<script name="classes">
    class Point {
        constructor(timestamp, playerID, currPlayerTotal) {
            this.timestamp = timestamp || new Date();
            this.playerID = playerID;
            this.currPlayerTotal = currPlayerTotal;
        }
    }
    class Person {
        constructor(ID, name, color) {
            this.ID = ID;
            this.name = name;
            this.color = color || "black";
        }
    }
    class Player {
        constructor(person, remote) {
            this.person = person;
            this.remote = remote;
            this.points = [];
        }
    }
    class Remote {
        constructor(name, buttonIDs) {
            this.name = name;
            this.buttonIDs = [];
            buttonIDs.forEach(button => {
                this.buttonIDs.push(button);
            });
        }
    }
    class Match {
        constructor() {
            this.ID = guidGenerator();
            this.startTime = new Date();
            this.players = [];
            this.remotes = [];
            this.isRunning = false;
            this.latestPoint = null;
        }
        addPoint(playerID) {
            var i = this.players.map(x => x.person.ID).indexOf(playerID);
            var now = new Date();
            this.players[i].points.push(new Point(now, playerID, this.playerScores[i] + 1));
            this.latestPoint = now;
        }
        addPlayer(player) {
            if (!this.players.map(x => x.person.ID).filter(n => n == player.person.ID).length) {
                if (this.enoughPlayers) this.players.splice(0, 1);
                this.players.push(player);
            }
            // tässä voisi tarkistaa onko jollain jo samainen remote
        }
        get playerScores() {
            return this.players.map(x => x.points.length);
            // return [
            //     this.points.filter(n => n.playerID == this.players[0].ID).length,
            //     this.points.filter(n => n.playerID == this.players[1].ID).length
            // ]
        }
        get playerCount() {
            return this.players.filter(n => n != undefined).length;
        }
        get enoughPlayers() {
            return this.playerCount == 2;
        }
    }
</script>
<script>
    Vue.component('linechart', {
        template: `<div class="linechart" :id="id">
    <svg :width="width" :height="height">
        <g>
                <path v-for="(player,i) in match.players" class="line" :d="paths.lines[i]" :style="{ stroke: player.person.color}" />
                <!--<path v-for="paths.lines" class="line" :d="paths.line" />-->
            <path class="selector" :d="paths.selector" />
        </g>
    </svg>
    </div>`,
        props: {
            latestpoint: {
                type: Date,
                default: () => null,
            },
            currpoints: {
                type: Array,
                default: () => [],
            },
            margin: {
                type: Object,
                default: () => ({
                    left: 0,
                    right: 0,
                    top: 10,
                    bottom: 10,
                }),
            },
            ceil: {
                type: Number,
                default: 100,
            },
            match: {
                type: Object,
                default: () => {},
            },
        },
        data() {
            return {
                id: '',
                width: 0,
                height: 0,
                paths: {
                    area: '',
                    lines: ['', ''],
                    selector: '',
                },
                scaled: {
                    x: null,
                    y: null,
                },
                animatedData: [],
                points: [],
            }
        },
        computed: {
            padded() {
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                return {
                    width,
                    height
                };
            },
        },
        mounted() {
            window.addEventListener('resize', this.onResize);
            this.onResize();
        },
        beforeDestroy() {
            window.removeEventListener('resize', this.onResize);
        },
        watch: {
            latestpoint: function dataChanged(newData, oldData) {
                // this.tweenData(newData, oldData);
                this.update()
            },
            width: function widthChanged() {
                this.initialize();
                this.update();
            },
        },
        methods: {
            onResize() {
                this.width = this.$el.offsetWidth;
                this.height = this.$el.offsetHeight;
            },
            createLine: d3.line().x(d => d.x).y(d => d.y),
            createValueSelector: d3.area().x(d => d.x).y0(d => d.max).y1(0),
            initialize() {
                this.scaled.x = d3.scaleTime().range([0, this.padded.width]);
                this.scaled.y = d3.scaleLinear().range([this.padded.height, 0]);
                this.scaled.z = d3.scaleOrdinal(d3.schemeCategory10);
                d3.axisLeft().scale(this.scaled.y);
                d3.axisBottom().scale(this.scaled.x);
            },
            update() {
                var allPoints = this.match.players.map(p => p.points).reduce((a, b) => a.concat(b), []);
                this.scaled.x.domain(d3.extent(allPoints.concat([{
                    timestamp: this.match.startTime
                }]), (d, i) => d.timestamp));
                this.scaled.y.domain([0, Math.max(this.ceil, d3.max(allPoints, d => d.currPlayerTotal))]);
                this.points = [
                    [],
                    []
                ];
                this.match.players.forEach((player, i) => {
                    // origo
                    if (player.points.length) {
                        this.points[i].push({
                            x: this.scaled.x(this.match.startTime),
                            y: this.scaled.y(0),
                            max: this.height,
                        });
                    }
                    player.points.forEach(point => {
                        this.points[i].push({
                            x: this.scaled.x(point.timestamp),
                            y: this.scaled.y(point.currPlayerTotal),
                            max: this.height,
                        });
                    });
                });
                this.paths.lines.splice(0, this.paths.lines.length);
                for (let i = 0; i < 2; i++) {
                    var t = this.createLine(this.points[i]);
                    if (t) {
                        this.paths.lines.push(t);
                    }
                }
            },
        }
    });
</script>

<script>
    var app = new Vue({
        el: '#app',
        data: function () {
            return {
                matches: [],
                persons: [
                    new Person(1, "Antti", "red"),
                    new Person(2, "Toinen", "blue"),
                    new Person(3, "Kolmas", "green")
                ],
                message: 'Hello Vue!',
                remotes: [
                    new Remote("A", [12890956]),
                    new Remote("B", [12890948])
                ],
                selectedPerson: {}, // uuden henkilön lisäämiseen
                selectedRemote: {}, // uuden henkilön lisäämiseen,
                error: ""
            }
        },
        computed: {
            currentMatch: function () {
                return this.matches[this.matches.length - 1];
            },
        },
        methods: {
            moment: () => moment(),
            guidGenerator: function () {
                return guidGenerator();
            },
            addMatch: function () {
                this.matches.push(new Match());
            },
            addPlayer: function (player) {
                this.currentMatch.addPlayer(player);
                //$('#flipPoints' + player.person.ID).bFlipText({text: '01', css: my_style});
            },
            addSelectedPlayerWithRadio: function () {
                this.currentMatch.addPlayer(new Player(this.selectedPerson, this.selectedRemote));
            },
            addPoint: function (RFID) {
                RFID = parseInt(RFID);
                var tplayer = this.currentMatch.players.filter(p => p.remote.buttonIDs.includes(RFID));
                if (tplayer.length) {
                    this.currentMatch.addPoint(tplayer[0].person.ID);
                    this.latestPoint = new Date();
                }
            }
        },
        filters: {
            moment: function (date) {
                return moment(date).format('L, LT');
            }
        },
        created: function () {
            this.addMatch();
            this.addPlayer(new Player(this.persons[0], this.remotes[0]));
            this.addPlayer(new Player(this.persons[1], this.remotes[1]));
        }
    })
</script>

</html>